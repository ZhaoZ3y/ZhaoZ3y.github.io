---
title: "ç®—æ³• 1.27"
date: 2026-01-27T12:54:06+08:00
draft: true
description: ""
summary: "æ¯æ—¥ç®—æ³•-1.27"
tags: ["ç®—æ³•"]
---

# 1.27

## [äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) (æŒæ¡ç¨‹åº¦ï¼šä¸­)

ä¸­é—´çš„å¤„ç†è¿˜æ˜¯æœ‰ç‚¹å¿˜è®°äº†ï¼Œ è€Œä¸”åœ¨è¿›äº†ç•Œé¢å°±ç¥äº†å‡ çœ¼ç»“æœè¿˜æ˜¯è®°ä¸å¤ªæ¸…ğŸ˜“

~~~cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != nullptr && right != nullptr) return root;
        if (left != nullptr) return left;
        return right;
    }
};
~~~

## [ç¯å½¢é“¾è¡¨](https://leetcode.cn/problems/linked-list-cycle/description/) (æŒæ¡ç¨‹åº¦ï¼šé«˜)

ç®€å•çš„å¿«æ…¢æŒ‡é’ˆï¼Œç®€å•é¢˜è¿˜æ˜¯æ¯”è¾ƒeasyçš„

~~~cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
};
~~~

## [æœ€é•¿é€’å¢å­åºåˆ— ](https://leetcode.cn/problems/longest-increasing-subsequence/description/)(æŒæ¡ç¨‹åº¦ï¼š ä¸­)

æŠŠè¿™é“é¢˜å’Œå¦å¤–ä¸€ä¸ªææ··äº†ï¼Œè¿™ä¸ªæ˜¯dpï¼Œå¦ä¸€ä¸ªæ˜¯setï¼ŒåŠ¨æ€è§„åˆ’è¿˜æ˜¯æ¶å¿ƒå•Š

~~~cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        vector<int> dp(n + 1, 1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans; 
    }
};
~~~

## [èºæ—‹çŸ©é˜µ](https://leetcode.cn/problems/spiral-matrix/description/) (æŒæ¡ç¨‹åº¦ï¼šä¸­)

çŸ¥é“æ€ä¹ˆå†™ï¼Œå°±æ˜¯æœ‰ä¸€äº›è·ŸçŸ©é˜µç›¸å…³çš„ä¸ç†Ÿï¼Œè¿˜æœ‰dirs[4] [2]çš„æ–¹å‘è¿˜æ˜¯è®°ä¸å¤ªæ¸…ï¼Œåç»­ä¼°è®¡å¾—å¤šèŠ±äº›åŠŸå¤«åœ¨è¿™ä¸Šé¢

~~~cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        vector<int> ans(m * n);
        int dir = 0, i = 0, j = 0;
        for (int k = 0; k < m * n; k++) {
            ans[k] = matrix[i][j];
            matrix[i][j] = INT_MAX;
            int x = i + dirs[dir][0], y = j + dirs[dir][1];
            if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == INT_MAX) dir = (dir + 1) % 4;
            i += dirs[dir][0];
            j += dirs[dir][1];
        }
        return ans;
    }
};
~~~

## [é‡æ’é“¾è¡¨](https://leetcode.cn/problems/reorder-list/description/) (æŒæ¡ç¨‹åº¦ï¼š ä¸­)

å°±æ˜¯å¿«æ…¢æŒ‡é’ˆæ‰¾ä¸­ç‚¹ï¼Œç„¶åæ–­å¼€ï¼Œå†åè½¬ï¼Œç„¶åä¸€ä¸ªä¸€ä¸ªæ¥ä¸Š

~~~cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        if (!head || !head->next) return;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* head2 = reverseList(slow->next);
        slow->next = nullptr;
        ListNode* p1 = head;
        ListNode* p2 = head2;
        while (p2) {
            ListNode* n1 = p1->next;
            ListNode* n2 = p2->next;
            p1->next = p2;
            p2->next = n1;
            p1 = n1;
            p2 = n2;
        }
    }
    ListNode* reverseList(ListNode* node) {
        ListNode* pre = nullptr;
        while (node) {
            ListNode* nxt = node->next;
            node->next = pre;
            pre = node;
            node = nxt;
        }
        return pre;
    }
};
~~~



