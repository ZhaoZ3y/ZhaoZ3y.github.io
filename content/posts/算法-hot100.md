---
title: "算法 Hot100"
date: 2026-02-12T13:32:24+08:00
draft: true
description: ""
tags: ["算法", "热题100"]
---

# 热题100

## 1. [两数之和](https://leetcode.cn/problems/two-sum/) `简单题` `哈希表`

~~~cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> map;
        for (int i = 0; i < n; i++) {
            if (map.count(target - nums[i])) {
                return {map[target - nums[i]], i};
            }
            map[nums[i]] = i;
        }
        return {};
    }
};
~~~

## 2. [字母异位词分组](https://leetcode.cn/problems/group-anagrams/) `中等题 ` `哈希表`

~~~cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        int n = strs.size();
        vector<vector<string>> ans;
        unordered_map<string, vector<string>> map;
        for (int i = 0; i < n; i++) {
            string key = strs[i];
            sort(key.begin(), key.end());
            map[key].push_back(strs[i]);
        }
        for (auto [_, value] : map) {
            ans.push_back(value);
        }
        return ans;
    }
};
~~~

## 3. [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/) `中等题` `哈希表`

~~~cpp
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> set(nums.begin(), nums.end());
        int n = nums.size();
        int ans = 0;
        for (int num : set) {
            if (!set.count(num - 1)) {
                int curN = num, curL = 1;
                while(set.count(curN + 1)) {
                    curN++;
                    curL++;
                }
                ans = max(ans, curL);
            }
        }
        return ans;
    }
};
~~~

## 4. [移动零 ](https://leetcode.cn/problems/move-zeroes/)`简单题` `双指针`

~~~cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        int i0 = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] != 0) {
                swap(nums[i], nums[i0]);
                i0++;
            }
        }
    }
};
~~~

## 5. [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/) `中等题` `双指针`

~~~cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int left = 0, right = n - 1;
        int ans = 0;
        while (left < right) {
            int area = (right - left) * min(height[left], height[right]);
            ans = max(ans, area);
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return ans;
    }
};
~~~

## 6. [三数之和](https://leetcode.cn/problems/3sum/) `中等题` `双指针` `剪枝`

~~~cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        vector<vector<int>> ans;
        for (int i = 0; i < n - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break;
            if (nums[i] + nums[n - 2] + nums[n - 1] < 0) continue;
            int left = i + 1, right = n - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum < 0) {
                    left++;
                } else if (sum > 0) {
                    right--;
                } else {
                    ans.push_back({nums[i], nums[left], nums[right]}); 
                    left++;
                    right--;
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                }
            }
        }
        return ans;
    }
};
~~~

## 7. [接雨水](https://leetcode.cn/problems/trapping-rain-water/) `困难题` `双指针` 

~~~cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int preMax = height[0], sufMax = height[n - 1];
        int left = 0, right = n - 1;
        int ans = 0;
        while (left < right) {
            preMax = max(preMax, height[left]);
            sufMax = max(sufMax, height[right]);
            if (preMax < sufMax) {
                ans += preMax - height[left];
                left++;
            } else {
                ans += sufMax - height[right];
                right--;
            }
        }
        return ans;
    }
};
~~~

## 8. [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) `中等题` `滑动窗口` `哈希表`

~~~cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        unordered_map<char, int> map;
        int left = 0, ans = 0;
        for (int right = 0; right < n; right++) {
            map[s[right]]++;
            while (map[s[right]] > 1) {
                map[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
}; 
~~~

## 9. [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/) `中等题` ``滑动窗口`` `哈希表 `

~~~cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int m = s.size(), n = p.size();
        if (m < n) return {};
        vector<int> ans;
        vector<int> sMap(26), pMap(26);
        for (int i = 0; i < n; i++) {
            pMap[p[i] - 'a']++;
        }
        for (int right = 0; right < m; right++) {
            sMap[s[right] - 'a']++;
            int left = right - n + 1;
            if (left < 0) continue;
            if (sMap == pMap) ans.push_back(left);
            sMap[s[left] - 'a']--;
        }
        return ans;
    }
};
~~~

## 10. [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) `中等题` `前缀和` `哈希表`

~~~cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        map[0] = 1;
        int sum = 0, ans = 0;
        for (int n : nums) {
            sum += n;
            if (map.count(sum - k)) {
                ans += map[sum - k];
            }
            map[sum]++;
        }
        return ans;
    }
};
~~~

## 11. [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/) `困难题` `滑动窗口` `双向队列`

~~~cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> ans;
        deque<int> q;
        for (int i = 0; i < n; i++) {
            while (!q.empty() && nums[q.back()] <= nums[i]) q.pop_back();
            q.push_back(i);
            int left = i - k + 1;
            if (q.front() < left) q.pop_front();
            if (left >= 0) ans.push_back(nums[q.front()]);
        }
        return ans;
    }
};
~~~

## 12. [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/) `困难题` `滑动窗口` `哈希表`

~~~cpp
class Solution {
public:
    string minWindow(string s, string t) {
        int cnt[128]{};
        for (char c : t) cnt[c]++;
        int left = 0, right = 0;
        int need = t.size(), minLen = INT_MAX, start = 0;
        while (right < s.size()) {
            if (cnt[s[right]] > 0) need--;
            cnt[s[right]]--;
            right++;
            while (need == 0) {
                if (right - left < minLen) {
                    minLen = right - left;
                    start = left;
                }
                cnt[s[left]]++;
                if (cnt[s[left]] > 0) need++;
                left++;
            }
        }   
        return minLen == INT_MAX ? "" : s.substr(start, minLen);
    }
};
~~~

## 13. [最大子数组和](https://leetcode.cn/problems/maximum-subarray/) `中等题` `前缀和` `贪心`

~~~cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int ans = INT_MIN;
        int minPre = 0, pre = 0;
        for (int i = 0; i < n; i++) {
            pre += nums[i];
            ans = max(ans, pre - minPre);
            minPre = min(minPre, pre);
        }
        return ans;
    }
};
~~~

## 14. [合并区间](https://leetcode.cn/problems/merge-intervals/) `中等题` `排序`

~~~cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> ans;
        sort(intervals.begin(), intervals.end());
        for (vector<int> interval : intervals) {
            int n = ans.size();
            if (!ans.empty() && interval[0] <= ans[n - 1][1]) {
                ans[n - 1][1] = max(interval[1], ans[n - 1][1]);
            } else {
                ans.push_back(interval);
            }
        }
        return ans;
    }
};
~~~

## 15. [轮转数组](https://leetcode.cn/problems/rotate-array/) `中等题` `双指针`

~~~cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start++;
            end--;
        }
    }
};
~~~

## 16. [除了自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/) `中等题` `前缀积` `后缀积`

~~~cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> pre(n, 1), suf(n, 1), ans(n, 1);
        for (int i = 1; i < n; i++) {
            pre[i] = pre[i - 1] * nums[i - 1];
        }
        for (int i = n - 2; i >= 0; i--) {
            suf[i] = suf[i + 1] * nums[i + 1];
        }
        for (int i = 0; i < n; i++) {
            ans[i] = pre[i] * suf[i];
        }
        return ans;
    }
};
~~~

## 17. [缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/) `困难题` `原地哈希`

~~~cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            while (nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
};
~~~

## 18. [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/) `中等题` `矩阵` `哈希表`

~~~cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<bool> row(m, false), col(n, false);
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if ( row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
};
~~~

## 19. [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/) `中等题` `矩阵` `方向`

~~~cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //右下左上
        vector<int> ans(m * n);
        int dir = 0, i = 0, j = 0;
        for (int k = 0; k < m * n; k++) {
            ans[k] = matrix[i][j];
            matrix[i][j] = INT_MAX;
            int x = i + dirs[dir][0], y = j + dirs[dir][1];
            if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == INT_MAX) {
                dir = (dir + 1) % 4;
            }
            i += dirs[dir][0];
            j += dirs[dir][1];
        }
        return ans;
    }
};
~~~

## 20. [旋转图像](https://leetcode.cn/problems/rotate-image/) `中等题` `矩阵` 

~~~cpp
//顺时针
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }   
    }
};
~~~

~~~cpp
//逆时针
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }   
    }
};
~~~

