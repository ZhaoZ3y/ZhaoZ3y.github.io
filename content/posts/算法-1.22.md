---
title: "æ¯æ—¥ç®—æ³• 1.21"
date: 2026-01-21T16:21:46+08:00
draft: false
description: ""
tags: ["ç®—æ³•"]
---

# 1.21

## [æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/) (æŒæ¡ç¨‹åº¦ï¼š ä¸­)

éƒ¨åˆ†è¿˜æ˜¯å­˜åœ¨å¿˜äº†çš„ï¼Œä¸­é—´å…³äºå“ˆå¸Œè¡¨çš„æœ‰ç‚¹æ²¡æŒæ¡

~~~cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        unordered_map<char, int> map;
        int ans = 0, left = 0;
        for (int right = 0; right < n; right++) {
            map[s[right]]++;
            while (map[s[right]] > 1) {
                map[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
~~~

## [LRUç¼“å­˜](https://leetcode.cn/problems/lru-cache/) (æŒæ¡ç¨‹åº¦ï¼š é«˜)

è¿™ä¸ªæˆ‘å·²ç»ä¼šèƒŒäº†ğŸ˜“

~~~~go
type Node struct {
    key, val int
    prev, next *Node
}

type LRUCache struct {
    Capacity int
    Cache map[int]*Node
    Head *Node
    Tail *Node
}


func Constructor(capacity int) LRUCache {
    head := &Node{}
    tail := &Node{}
    head.next = tail
    tail.prev = head
    return LRUCache{
        Capacity: capacity,
        Cache: make(map[int]*Node),
        Head: head,
        Tail: tail,
    }
}

func (l *LRUCache) addToHead(node *Node) {
    node.prev = l.Head
    node.next = l.Head.next
    l.Head.next.prev = node
    l.Head.next = node
}

func (l *LRUCache) deleteNode(node *Node) {
    node.next.prev = node.prev
    node.prev.next = node.next
}

func (l *LRUCache) Get(key int) int {
    if node, ok := l.Cache[key]; ok {
        l.deleteNode(node);
        l.addToHead(node);
        return node.val
    }
    return -1
}


func (l *LRUCache) Put(key int, value int)  {
    if node, ok := l.Cache[key]; ok {
        node.val = value
        l.deleteNode(node)
        l.addToHead(node)
    } else {
        if len(l.Cache) >= l.Capacity {
            deleteNode := l.Tail.prev
            l.deleteNode(deleteNode)
            delete(l.Cache, deleteNode.key)
        }
        newNode := &Node{key: key, val: value}
        l.addToHead(newNode)
        l.Cache[key] = newNode
    }
}


/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
~~~~

## [åè½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-linked-list/) (æŒæ¡ç¨‹åº¦ï¼š é«˜)

ç®€å•é¢˜è¿˜æ˜¯æ‹¿ä¸‹è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„

~~~cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = nullptr;
        while (cur != nullptr) {
            ListNode* nxt = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
};
~~~

## [æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/) (æŒæ¡ç¨‹åº¦ï¼š ä¸­)

è¿™ä¸ªå¿«é€Ÿé€‰æ‹©è¿˜æ˜¯ç•¥å¾®ä¸å¤ªç†Ÿ

~~~cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        srand(time(0));
        int n = nums.size();
        return quickSelect(nums, n - k, 0, n - 1);
    }
    int quickSelect(vector<int>& nums, int k, int left, int right) {
        if (left == right) return nums[left];
        int random = left + rand() % (right - left + 1);
        swap(nums[left], nums[random]);
        int pivot = nums[left];
        int i = left - 1, j = right + 1;
        while (true) {
            do i++; while (nums[i] < pivot);
            do j--; while (nums[j] > pivot);
            if (i >= j) break;
            swap(nums[i], nums[j]);
        }
        if (k <= j) return quickSelect(nums, k, left, j);
        else return quickSelect(nums, k, j + 1, right);
    }
};
~~~

## [Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/) (æŒæ¡ç¨‹åº¦ï¼š ä¸­)

å¤„ç†p0å’Œå°¾éƒ¨çš„æ—¶å€™æ²¡è®°ä½

~~~cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy = new ListNode(0);
        dummy->next = head;
        ListNode* p0 = dummy;
        int n = 0;
        for (ListNode* cur = head; cur != nullptr; cur = cur->next) {
            n++;
        }
        ListNode* cur = head;
        while (n >= k) {
            n -= k;
            ListNode* tail = cur;
            ListNode* pre = nullptr;
            for (int i = 0; i < k; i++) {
                ListNode* nxt = cur->next;
                cur->next = pre;
                pre = cur;
                cur = nxt;
            }
            p0->next = pre;
            tail->next = cur;
            p0 = tail;
        }
        return dummy->next;
    }
};
~~~

