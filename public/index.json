
[{"content":"","date":"2026 å¹´ 1 æœˆ 24 æ—¥","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026 å¹´ 1 æœˆ 24 æ—¥","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2026 å¹´ 1 æœˆ 24 æ—¥","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"ç®—æ³•","type":"tags"},{"content":" 1.24 # äºŒå‰æ ‘çš„å±‚åºéå† (æŒæ¡ç¨‹åº¦ï¼šä¸­) # è¾¹ç•Œçš„å¤„ç†è¿˜æ˜¯æœ‰äº›è®¸çš„é—®é¢˜ï¼Œä½†æ˜¯å¤§ä½“çš„æ–¹å‘æ˜¯æ²¡æœ‰é—®é¢˜çš„\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { if (root == nullptr) return {}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while (!q.empty()) { int n = q.size(); vector\u0026lt;int\u0026gt; vals; for (int i = 0; i \u0026lt; n; i++) { TreeNode* node = q.front(); q.pop(); vals.push_back(node-\u0026gt;val); if (node-\u0026gt;left != nullptr) q.push(node-\u0026gt;left); if (node-\u0026gt;right != nullptr) q.push(node-\u0026gt;right); } ans.push_back(vals); } return ans; } }; æœç´¢æ—‹è½¬æ’åºæ•°ç»„ (æŒæ¡ç¨‹åº¦ï¼šä½) # æƒ³èµ·æ¥äº†ä»–æ˜¯è¦æ ¹æ®åˆ¤æ–­targetæ˜¯åœ¨å‰é¢æœ‰åºåŒºåŸŸè¿˜æ˜¯åç»­æœ‰åºåŒºåŸŸï¼Œå†è¿›è¡ŒäºŒåˆ†çš„ï¼Œä½†æ˜¯è¾¹ç•Œå¤„ç†è¿˜æ˜¯è®°å¾—ä¸å¤ªæ¸…æ¥šï¼Œåç»­è¿˜æ˜¯è¦å¥½å¥½ç†Ÿç»œä¸€ä¸‹\nclass Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); int left = 0, right = n - 1; while (left \u0026lt;= right) { int mid = (left + right) / 2; if (nums[mid] == target) return mid; if (nums[0] \u0026lt;= nums[mid]) { if (nums[0] \u0026lt;= target \u0026amp;\u0026amp; target \u0026lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } else { if (nums[mid] \u0026lt; target \u0026amp;\u0026amp; target \u0026lt;= nums[n - 1]) { left = mid + 1; } else { right = mid - 1; } } } return -1; } }; å²›å±¿æ•°é‡ (æŒæ¡ç¨‹åº¦ï¼š é«˜) # å…¸å‹çš„dfsäº†\nclass Solution { public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(), n = grid[0].size(); int ans = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { dfs(grid, m, n, i, j); ans++; } } } return ans; } void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int m, int n, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n || grid[i][j] == \u0026#39;0\u0026#39;) return; grid[i][j] = \u0026#39;0\u0026#39;; dfs(grid, m, n, i + 1, j); dfs(grid, m, n, i - 1, j); dfs(grid, m, n, i, j + 1); dfs(grid, m, n, i, j - 1); } }; ä¸¤æ•°ä¹‹å’Œ (æŒæ¡ç¨‹åº¦ï¼šä¸­) # è¿™ä¸ªç®€å•é¢˜æˆ‘å·²ç»ä¸ç†Ÿå¾ˆä¹…äº†ï¼Œæ€»æ˜¯å¿˜è®°ä¸€äº›å¾ªç¯å†…çš„ä¸œè¥¿ï¼Œä½†æ˜¯å¥½æ­¹å¤§è‡´æ–¹å‘æ²¡å•¥é—®é¢˜\nclass Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; pos; int n = nums.size(); for (int i = 0; i \u0026lt; n; i++) { int x = nums[i]; if (pos.count(target - x)) { return {pos[target - x], i}; } pos[x] = i; } return {}; } }; å…¨æ’åˆ— (æŒæ¡ç¨‹åº¦ï¼šé«˜) # ç®€å•çš„å›æº¯\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; path; vector\u0026lt;bool\u0026gt; used; void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int n, int i) { if (i == n) { ans.push_back(path); return; } for (int j = 0; j \u0026lt; n; j++) { if (used[j] == true) continue; used[j] = true; path.push_back(nums[j]); dfs(nums, n, i + 1); path.pop_back(); used[j] = false; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); used = vector\u0026lt;bool\u0026gt;(n, false); dfs(nums, n, 0); return ans; } }; ","date":"2026 å¹´ 1 æœˆ 24 æ—¥","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95-1.24/","section":"Posts","summary":"æ¯æ—¥ç®—æ³•-1.24","title":"ç®—æ³• 1.24","type":"posts"},{"content":"","date":"2026 å¹´ 1 æœˆ 24 æ—¥","externalUrl":null,"permalink":"/","section":"æ–‡ç« ","summary":"","title":"æ–‡ç« ","type":"page"},{"content":" 1.23 # ä¸‰æ•°ä¹‹å’Œ (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # å¿˜è®°äº†éƒ¨åˆ†å¦‚è¦å…ˆæ’åºè¿˜æœ‰å‰ªæéƒ¨åˆ†å‡ºç°äº†é—®é¢˜\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; int n = nums.size(); for (int i = 0; i \u0026lt; n - 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; if (nums[i] + nums[i + 1] + nums[i + 2] \u0026gt; 0) break; if (nums[i] + nums[n - 2] + nums[n - 1] \u0026lt; 0) continue; int left = i + 1, right = n - 1; while (left \u0026lt; right) { int sum = nums[i] + nums[left] + nums[right]; if (sum \u0026gt; 0) right--; else if (sum \u0026lt; 0) left++; else { ans.push_back({nums[i], nums[left], nums[right]}); left++; right--; while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] == nums[left - 1]) left++; while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] == nums[right + 1]) right--; } } } return ans; } }; æœ€å¤§å­æ•°ç»„å’Œ (æŒæ¡ç¨‹åº¦ï¼šé«˜) # å…¶å®çœ‹åˆ°é¢˜è¿˜æ˜¯æœ‰ç‚¹æ‡µçš„ï¼Œä½†æ˜¯è¿˜æ˜¯è§‰å¾—æ˜¯å‰ç¼€å’Œï¼Œç»“æœè¿˜çœŸæ˜¯\nclass Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int ans = INT_MIN; int minPre = 0, pre = 0; for (int i = 0; i \u0026lt; n; i++) { pre += nums[i]; ans = max(ans, pre - minPre); minPre = min(minPre, pre); } return ans; } }; æ‰‹æ’•å¿«æ’ (æŒæ¡ç¨‹åº¦ï¼šä¸­) # è·Ÿå‰é¢çš„å¿«é€Ÿé€‰æ‹©ä¸€æ ·çš„å†™æ³•ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸å¤ªç†Ÿ\nclass Solution { public: vector\u0026lt;int\u0026gt; sortArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { srand(time(0)); quickSort(nums, 0, nums.size() - 1); return nums; } void quickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left == right) return; int random = left + rand() % (right - left + 1); swap(nums[left], nums[random]); int pivot = nums[left]; int i = left - 1, j = right + 1; while (true) { do i++; while (nums[i] \u0026lt; pivot); do j--; while (nums[j] \u0026gt; pivot); if (i \u0026gt;= j) break; swap(nums[i], nums[j]); } quickSort(nums, left, j); quickSort(nums, j + 1, right); } }; æœ€é•¿å›æ–‡å­ä¸² (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # è¿™ä¸ªå°±æ˜¯ä¸­å¿ƒæ‰©æ•£ç®—æ³•äº†ï¼Œä½†æ˜¯åœ¨ä¸­å¿ƒæ‰©æ•£çš„whileå¾ªç¯æ¡ä»¶çš„æ¡ä»¶å¤„ç†çš„ä¸æ˜¯ç‰¹åˆ«å¥½\nclass Solution { public: string longestPalindrome(string s) { int n = s.size(); int start = 0, end = 0; for (int i = 0; i \u0026lt; n; i++) { auto [l1, r1] = expandFromCenter(s, i, i); auto [l2, r2] = expandFromCenter(s, i, i + 1); if (r1 - l1 \u0026gt; end - start) { start = l1; end = r1; } if (r2 - l2 \u0026gt; end - start) { start = l2; end = r2; } } return s.substr(start, end - start + 1); } pair\u0026lt;int, int\u0026gt; expandFromCenter(const string\u0026amp; s, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; s.size() \u0026amp;\u0026amp; s[left] == s[right]) { left--; right++; } return {left + 1, right - 1}; } }; åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ (æŒæ¡ç¨‹åº¦ï¼š é«˜) # ä¾æ—§ç®€å•é¢˜\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode* dummy = new ListNode(0); ListNode* cur = dummy; while (list1 \u0026amp;\u0026amp; list2) { if (list1-\u0026gt;val \u0026lt; list2-\u0026gt;val) { cur-\u0026gt;next = list1; list1 = list1-\u0026gt;next; } else { cur-\u0026gt;next = list2; list2 = list2-\u0026gt;next; } cur = cur-\u0026gt;next; } if (list1) cur-\u0026gt;next = list1; else cur-\u0026gt;next = list2; return dummy-\u0026gt;next; } }; ","date":"2026 å¹´ 1 æœˆ 23 æ—¥","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95-1.23/","section":"Posts","summary":"æ¯æ—¥ç®—æ³•æ€»ç»“-1.23","title":"ç®—æ³• 1.23","type":"posts"},{"content":" 1.21 # æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # éƒ¨åˆ†è¿˜æ˜¯å­˜åœ¨å¿˜äº†çš„ï¼Œä¸­é—´å…³äºå“ˆå¸Œè¡¨çš„æœ‰ç‚¹æ²¡æŒæ¡\nclass Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); unordered_map\u0026lt;char, int\u0026gt; map; int ans = 0, left = 0; for (int right = 0; right \u0026lt; n; right++) { map[s[right]]++; while (map[s[right]] \u0026gt; 1) { map[s[left]]--; left++; } ans = max(ans, right - left + 1); } return ans; } }; LRUç¼“å­˜ (æŒæ¡ç¨‹åº¦ï¼š é«˜) # è¿™ä¸ªæˆ‘å·²ç»ä¼šèƒŒäº†ğŸ˜“\ntype Node struct { key, val int prev, next *Node } type LRUCache struct { Capacity int Cache map[int]*Node Head *Node Tail *Node } func Constructor(capacity int) LRUCache { head := \u0026amp;Node{} tail := \u0026amp;Node{} head.next = tail tail.prev = head return LRUCache{ Capacity: capacity, Cache: make(map[int]*Node), Head: head, Tail: tail, } } func (l *LRUCache) addToHead(node *Node) { node.prev = l.Head node.next = l.Head.next l.Head.next.prev = node l.Head.next = node } func (l *LRUCache) deleteNode(node *Node) { node.next.prev = node.prev node.prev.next = node.next } func (l *LRUCache) Get(key int) int { if node, ok := l.Cache[key]; ok { l.deleteNode(node); l.addToHead(node); return node.val } return -1 } func (l *LRUCache) Put(key int, value int) { if node, ok := l.Cache[key]; ok { node.val = value l.deleteNode(node) l.addToHead(node) } else { if len(l.Cache) \u0026gt;= l.Capacity { deleteNode := l.Tail.prev l.deleteNode(deleteNode) delete(l.Cache, deleteNode.key) } newNode := \u0026amp;Node{key: key, val: value} l.addToHead(newNode) l.Cache[key] = newNode } } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */ åè½¬é“¾è¡¨ (æŒæ¡ç¨‹åº¦ï¼š é«˜) # ç®€å•é¢˜è¿˜æ˜¯æ‹¿ä¸‹è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* cur = head; ListNode* pre = nullptr; while (cur != nullptr) { ListNode* nxt = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = nxt; } return pre; } }; æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´  (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # è¿™ä¸ªå¿«é€Ÿé€‰æ‹©è¿˜æ˜¯ç•¥å¾®ä¸å¤ªç†Ÿ\nclass Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { srand(time(0)); int n = nums.size(); return quickSelect(nums, n - k, 0, n - 1); } int quickSelect(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int left, int right) { if (left == right) return nums[left]; int random = left + rand() % (right - left + 1); swap(nums[left], nums[random]); int pivot = nums[left]; int i = left - 1, j = right + 1; while (true) { do i++; while (nums[i] \u0026lt; pivot); do j--; while (nums[j] \u0026gt; pivot); if (i \u0026gt;= j) break; swap(nums[i], nums[j]); } if (k \u0026lt;= j) return quickSelect(nums, k, left, j); else return quickSelect(nums, k, j + 1, right); } }; Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # å¤„ç†p0å’Œå°¾éƒ¨çš„æ—¶å€™æ²¡è®°ä½\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; ListNode* p0 = dummy; int n = 0; for (ListNode* cur = head; cur != nullptr; cur = cur-\u0026gt;next) { n++; } ListNode* cur = head; while (n \u0026gt;= k) { n -= k; ListNode* tail = cur; ListNode* pre = nullptr; for (int i = 0; i \u0026lt; k; i++) { ListNode* nxt = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = nxt; } p0-\u0026gt;next = pre; tail-\u0026gt;next = cur; p0 = tail; } return dummy-\u0026gt;next; } }; ","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95-1.21/","section":"Posts","summary":"æ¯æ—¥ç®—æ³•æ€»ç»“-1.21","title":"æ¯æ—¥ç®—æ³• 1.21","type":"posts"},{"content":" 3ing # æˆ‘æ˜¯ä¸€ä¸ªèœé¸Ÿ gopher \u0026amp; pythonista\nSkills # \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\nMy GitHub Data # Work Load # \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e å¤šæ¨¡æ€ç®—æ³•æœåŠ¡ç«¯æ¶æ„å¼€å‘å®ä¹ ç”Ÿ(2025.08 - 2025.12)\nContact Me # ","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/about/","section":"About Me","summary":"","title":"About Me","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/categories/suancf/","section":"Categories","summary":"","title":"Suan'c'f","type":"categories"},{"content":"","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"ç®—æ³•","type":"categories"}]