
[{"content":"","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 1.21 # æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # éƒ¨åˆ†è¿˜æ˜¯å­˜åœ¨å¿˜äº†çš„ï¼Œä¸­é—´å…³äºå“ˆå¸Œè¡¨çš„æœ‰ç‚¹æ²¡æŒæ¡\nclass Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); unordered_map\u0026lt;char, int\u0026gt; map; int ans = 0, left = 0; for (int right = 0; right \u0026lt; n; right++) { map[s[right]]++; while (map[s[right]] \u0026gt; 1) { map[s[left]]--; left++; } ans = max(ans, right - left + 1); } return ans; } }; LRUç¼“å­˜ (æŒæ¡ç¨‹åº¦ï¼š é«˜) # è¿™ä¸ªæˆ‘å·²ç»ä¼šèƒŒäº†ğŸ˜“\ntype Node struct { key, val int prev, next *Node } type LRUCache struct { Capacity int Cache map[int]*Node Head *Node Tail *Node } func Constructor(capacity int) LRUCache { head := \u0026amp;Node{} tail := \u0026amp;Node{} head.next = tail tail.prev = head return LRUCache{ Capacity: capacity, Cache: make(map[int]*Node), Head: head, Tail: tail, } } func (l *LRUCache) addToHead(node *Node) { node.prev = l.Head node.next = l.Head.next l.Head.next.prev = node l.Head.next = node } func (l *LRUCache) deleteNode(node *Node) { node.next.prev = node.prev node.prev.next = node.next } func (l *LRUCache) Get(key int) int { if node, ok := l.Cache[key]; ok { l.deleteNode(node); l.addToHead(node); return node.val } return -1 } func (l *LRUCache) Put(key int, value int) { if node, ok := l.Cache[key]; ok { node.val = value l.deleteNode(node) l.addToHead(node) } else { if len(l.Cache) \u0026gt;= l.Capacity { deleteNode := l.Tail.prev l.deleteNode(deleteNode) delete(l.Cache, deleteNode.key) } newNode := \u0026amp;Node{key: key, val: value} l.addToHead(newNode) l.Cache[key] = newNode } } /** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */ åè½¬é“¾è¡¨ (æŒæ¡ç¨‹åº¦ï¼š é«˜) # ç®€å•é¢˜è¿˜æ˜¯æ‹¿ä¸‹è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* cur = head; ListNode* pre = nullptr; while (cur != nullptr) { ListNode* nxt = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = nxt; } return pre; } }; æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´  (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # è¿™ä¸ªå¿«é€Ÿé€‰æ‹©è¿˜æ˜¯ç•¥å¾®ä¸å¤ªç†Ÿ\nclass Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { srand(time(0)); int n = nums.size(); return quickSelect(nums, n - k, 0, n - 1); } int quickSelect(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int left, int right) { if (left == right) return nums[left]; int random = left + rand() % (right - left + 1); swap(nums[left], nums[random]); int pivot = nums[left]; int i = left - 1, j = right + 1; while (true) { do i++; while (nums[i] \u0026lt; pivot); do j--; while (nums[j] \u0026gt; pivot); if (i \u0026gt;= j) break; swap(nums[i], nums[j]); } if (k \u0026lt;= j) return quickSelect(nums, k, left, j); else return quickSelect(nums, k, j + 1, right); } }; Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨ (æŒæ¡ç¨‹åº¦ï¼š ä¸­) # å¤„ç†p0å’Œå°¾éƒ¨çš„æ—¶å€™æ²¡è®°ä½\n/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode* dummy = new ListNode(0); dummy-\u0026gt;next = head; ListNode* p0 = dummy; int n = 0; for (ListNode* cur = head; cur != nullptr; cur = cur-\u0026gt;next) { n++; } ListNode* cur = head; while (n \u0026gt;= k) { n -= k; ListNode* tail = cur; ListNode* pre = nullptr; for (int i = 0; i \u0026lt; k; i++) { ListNode* nxt = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = nxt; } p0-\u0026gt;next = pre; tail-\u0026gt;next = cur; p0 = tail; } return dummy-\u0026gt;next; } }; ","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/posts/%E7%AE%97%E6%B3%95-1.21/","section":"Posts","summary":"æ¯æ—¥ç®—æ³•æ€»ç»“-1.21","title":"æ¯æ—¥ç®—æ³• 1.21","type":"posts"},{"content":"","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"ç®—æ³•","type":"tags"},{"content":"","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/","section":"æ–‡ç« ","summary":"","title":"æ–‡ç« ","type":"page"},{"content":" 3ing # æˆ‘æ˜¯ä¸€ä¸ªèœé¸Ÿ gopher \u0026amp; pythonista\nSkills # \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e\nMy GitHub Data # Work Load # \u003c?xml version=\"1.0\" standalone=\"no\"?\u003e\u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e å¤šæ¨¡æ€ç®—æ³•æœåŠ¡ç«¯æ¶æ„å¼€å‘å®ä¹ ç”Ÿ(2025.08 - 2025.12)\nContact Me # ","date":"2026 å¹´ 1 æœˆ 21 æ—¥","externalUrl":null,"permalink":"/about/","section":"About Me","summary":"","title":"About Me","type":"about"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]